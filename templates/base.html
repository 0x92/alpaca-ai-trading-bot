<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Trading Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body class="bg-gray-100 p-4">
    {% block content %}{% endblock %}
    <script>
        const socket = io();
        const charts = {};
        const positionsStore = {};

        async function previewPrompt(name) {
            const form = document.querySelector(`#portfolio-${name} form[action$='set_prompt']`);
            if (!form) return;
            const textarea = form.querySelector('textarea[name="custom_prompt"]');
            const previewEl = document.getElementById('preview-' + name);
            if (!textarea || !previewEl) return;
            const data = new FormData();
            data.append('custom_prompt', textarea.value);
            try {
                const resp = await fetch(`/portfolio/${name}/preview_prompt`, {
                    method: 'POST',
                    body: data
                });
                const text = await resp.text();
                previewEl.textContent = text;
            } catch (err) {
                previewEl.textContent = 'error';
            }
        }

        function createChart(name, labels, values, benchValues) {
            const ctx = document.getElementById('chart-' + name).getContext('2d');
            charts[name] = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Equity',
                        data: values,
                        borderColor: 'rgb(75, 192, 192)',
                        tension: 0.1
                    }, {
                        label: 'Benchmark',
                        data: benchValues,
                        borderColor: 'rgb(153, 102, 255)',
                        borderDash: [5,5],
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false
                }
            });
        }

        function renderPositions(name) {
            const data = positionsStore[name] || [];
            const table = document.getElementById('positions-' + name);
            if (!table) return;
            const sortSelect = document.getElementById('pos-sort-' + name);
            const filterInput = document.getElementById('pos-filter-' + name);
            let items = data.slice();
            if (filterInput && filterInput.value) {
                const term = filterInput.value.toLowerCase();
                items = items.filter(pos => pos.symbol.toLowerCase().includes(term));
            }
            const sortKey = sortSelect ? sortSelect.value : 'symbol';
            items.sort((a, b) => {
                if (sortKey === 'pnl') return b.pnl - a.pnl;
                return a.symbol.localeCompare(b.symbol);
            });
            const tbody = table.querySelector('tbody');
            tbody.innerHTML = '';
            if (items.length === 0) {
                const row = document.createElement('tr');
                const td = document.createElement('td');
                td.colSpan = 5;
                td.textContent = 'No positions';
                row.appendChild(td);
                tbody.appendChild(row);
            } else {
                items.forEach(pos => {
                    const row = document.createElement('tr');
                    row.innerHTML =
                        `<td class="border px-1">${pos.symbol}</td>` +
                        `<td class="border px-1">${pos.qty}</td>` +
                        `<td class="border px-1">${pos.price.toFixed(2)}</td>` +
                        `<td class="border px-1">${pos.avg_price.toFixed(2)}</td>` +
                        `<td class="border px-1">${pos.pnl.toFixed(2)} (${(pos.pnl_pct*100).toFixed(2)}%)</td>`;
                    tbody.appendChild(row);
                });
            }
        }

        function attachPositionHandlers(name) {
            const sortSelect = document.getElementById('pos-sort-' + name);
            const filterInput = document.getElementById('pos-filter-' + name);
            if (sortSelect) sortSelect.addEventListener('change', () => renderPositions(name));
            if (filterInput) filterInput.addEventListener('input', () => renderPositions(name));
        }

        function updatePortfolios(data) {
            if (!Array.isArray(data)) return;
            data.forEach(p => {
                const el = document.getElementById('portfolio-' + p.name);
                if (!el) return;
                const select = el.querySelector('select[name="strategy_type"]');
                if (select) select.value = p.strategy_type;
                const promptArea = el.querySelector('textarea[name="custom_prompt"]');
                if (promptArea) promptArea.value = p.custom_prompt || '';
                el.querySelector('.cash').textContent = p.cash;
                el.querySelector('.portfolio_value').textContent = p.portfolio_value;
                const divScoreEl = el.querySelector('.divscore');
                if (divScoreEl) divScoreEl.textContent = p.diversification_score;
                const historyList = el.querySelector('.history');
                historyList.innerHTML = '';
                if (p.history.length === 0) {
                    historyList.innerHTML = '<li>No trades yet.</li>';
                } else {
                    p.history.forEach(t => {
                        const item = document.createElement('li');
                        item.textContent = `${t.symbol} ${t.side} ${t.qty} @ ${t.submitted_at}`;
                        historyList.appendChild(item);
                    });
                }

                const alertList = el.querySelector('.risk_alerts');
                if (alertList) {
                    alertList.innerHTML = '';
                    if (p.risk_alerts.length === 0) {
                        alertList.innerHTML = '<li>No alerts.</li>';
                    } else {
                        p.risk_alerts.forEach(a => {
                            const item = document.createElement('li');
                            item.textContent = a;
                            alertList.appendChild(item);
                        });
                    }
                }

                const corrTable = el.querySelector('#corr-' + p.name);
                if (corrTable) {
                    const body = corrTable.querySelector('tbody');
                    body.innerHTML = '';
                    Object.keys(p.correlation).forEach(rowSym => {
                        const row = document.createElement('tr');
                        const th = document.createElement('th');
                        th.textContent = rowSym;
                        th.className = 'border px-1';
                        row.appendChild(th);
                        const cols = p.correlation[rowSym];
                        Object.keys(cols).forEach(colSym => {
                            const td = document.createElement('td');
                            td.className = 'border px-1';
                            td.textContent = cols[colSym].toFixed(2);
                            row.appendChild(td);
                        });
                        body.appendChild(row);
                    });
                }

                const labels = p.equity_norm.map(e => e.time);
                const values = p.equity_norm.map(e => e.value);
                const benchValues = p.benchmark.map(b => b.value);
                if (!charts[p.name]) {
                    createChart(p.name, labels, values, benchValues);
                } else {
                    charts[p.name].data.labels = labels;
                    charts[p.name].data.datasets[0].data = values;
                    charts[p.name].data.datasets[1].data = benchValues;
                    charts[p.name].update();
                }

                positionsStore[p.name] = p.positions || [];
                attachPositionHandlers(p.name);
                renderPositions(p.name);
            });
        }

        socket.on('trade_update', updatePortfolios);
        // initial bootstrap from server rendered data
        document.addEventListener('DOMContentLoaded', () => {
            const dataElement = document.getElementById('initial-data');
            if (dataElement) {
                const portfolios = JSON.parse(dataElement.textContent);
                updatePortfolios(portfolios);
                portfolios.forEach(p => attachPositionHandlers(p.name));
            }
        });
    </script>
</body>
</html>
